# name: test/sql/create2_mine.test
# description: Test create2_mine table function - CREATE2 salt mining functionality
# group: [sql]

require quackeccak

# Test 1.1: Basic functionality - should return 100 addresses by default
query I
SELECT COUNT(*) FROM create2_mine(
    '0x0000000000000000000000000000000000000000',
    '0x0000000000000000000000000000000000000000000000000000000000000000',
    '0',
    '100',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '100'
);
----
100

# Test 1.2: Verify columns exist and types are correct
query I
SELECT COUNT(*) FROM (
    SELECT salt_hi, salt_lo, salt, addr_hi8, addr_mid8, addr_lo4, address, lz_bits, tz_bits 
    FROM create2_mine(
        '0x0000000000000000000000000000000000000000',
        '0x0000000000000000000000000000000000000000000000000000000000000000',
        '0',
        '100',
        '0',
        '0',
        '0',
        '0',
        '0',
        '0',
        '100'
    )
    LIMIT 1
);
----
1

# Test 1.3: Verify salt increments correctly
query II
SELECT salt_hi, salt_lo
FROM create2_mine(
    '0x0000000000000000000000000000000000000000',
    '0x0000000000000000000000000000000000000000000000000000000000000000',
    '0',
    '100',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '100'
)
LIMIT 3;
----
0	0
0	1
0	2

# Test 1.4: Verify address components are non-null
query I
SELECT COUNT(*) FROM (
    SELECT * FROM create2_mine(
        '0x0000000000000000000000000000000000000000',
        '0x0000000000000000000000000000000000000000000000000000000000000000',
        '0',
        '100',
        '0',
        '0',
        '0',
        '0',
        '0',
        '0',
        '100'
    )
    WHERE addr_hi8 IS NOT NULL 
      AND addr_mid8 IS NOT NULL 
      AND addr_lo4 IS NOT NULL
    LIMIT 10
);
----
10

# Test 1.5: Verify human-readable columns are properly formatted
query I
SELECT COUNT(*) FROM (
    SELECT * FROM create2_mine(
        '0x0000000000000000000000000000000000000000',
        '0x0000000000000000000000000000000000000000000000000000000000000000',
        '0',
        '100',
        '0',
        '0',
        '0',
        '0',
        '0',
        '0',
        '100'
    )
    WHERE salt LIKE '0x%' AND LENGTH(salt) = 66
      AND address LIKE '0x%' AND LENGTH(address) = 42
    LIMIT 10
);
----
10

# Test 2.1: Custom salt start and count
query I
SELECT COUNT(*) FROM create2_mine(
    '0x4e59b44847b379578588920ca78fbf26c0b4956c',
    '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
    '1000',  -- salt_start
    '50',    -- salt_count
    '0',     -- mask_hi8
    '0',     -- value_hi8
    '0',     -- mask_mid8
    '0',     -- value_mid8
    '0',     -- mask_lo4
    '0',     -- value_lo4
    '100'    -- max_results
);
----
50

# Test 2.2: Verify salt_start works correctly
query II
SELECT salt_hi, salt_lo
FROM create2_mine(
    '0x4e59b44847b379578588920ca78fbf26c0b4956c',
    '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
    '1000',
    '3',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '100'
);
----
0	1000
0	1001
0	1002

# Test 2.3: Numeric parameters (no quotes) should also work
query I
SELECT COUNT(*) FROM create2_mine(
    '0x4e59b44847b379578588920ca78fbf26c0b4956c',
    '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
    '2000',
    '25',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '100'
);
----
25

# Test 3.1: Pattern matching should limit results to max_results (VARCHAR version)
query I
SELECT COUNT(*) FROM create2_mine(
    '0x4e59b44847b379578588920ca78fbf26c0b4956c',
    '0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890',
    '0',
    '100000',
    '0xff00000000000000',  -- mask_hi8 (check first byte)
    '0x0000000000000000',  -- value_hi8 (want 0x00)
    '0',
    '0',
    '0',
    '0',
    '5'  -- max_results
);
----
5

# Test 3.2: Verify pattern matching actually filters (all results should match pattern)
query I
SELECT COUNT(*) FROM create2_mine(
    '0x4e59b44847b379578588920ca78fbf26c0b4956c',
    '0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890',
    '0',
    '100000',
    '0xff00000000000000',
    '0x0000000000000000',
    '0',
    '0',
    '0',
    '0',
    '10'
) WHERE (addr_hi8 & CAST('0xff00000000000000' AS UBIGINT)) = 0;
----
10

# Test 3.3: Test with numeric mask values
query I
SELECT COUNT(*) FROM create2_mine(
    '0x4e59b44847b379578588920ca78fbf26c0b4956c',
    '0xabcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890',
    '0',
    '100000',
    '18374686479671623680',  -- 0xff00000000000000 as decimal
    '0',
    '0',
    '0',
    '0',
    '0',
    '5'
);
----
5

# Test 4.1: Test lo4 pattern matching returns limited results
query I
SELECT COUNT(*) <= 1 FROM create2_mine(
    '0x4e59b44847b379578588920ca78fbf26c0b4956c',
    '0x5555555555555555555555555555555555555555555555555555555555555555',
    '0',
    '100000',
    '0',
    '0',
    '0',
    '0',
    '0x0000ffff',  -- mask_lo4
    '0x0000dead',  -- value_lo4 (looking for addresses ending in 'dead')
    '1'
);
----
true

# Test 4.2: Verify lo4 pattern matching works
query I
SELECT COUNT(*) FROM create2_mine(
    '0x4e59b44847b379578588920ca78fbf26c0b4956c',
    '0x5555555555555555555555555555555555555555555555555555555555555555',
    '0',
    '1000000',
    '0',
    '0',
    '0',
    '0',
    '0x0000000f',
    '0x00000005',
    '10'
) WHERE (addr_lo4 & CAST('0x0000000f' AS UINTEGER)) = CAST('0x00000005' AS UINTEGER);
----
10

# Test 5.1: Empty string should use defaults
query I
SELECT COUNT(*) FROM create2_mine(
    '0x4e59b44847b379578588920ca78fbf26c0b4956c',
    '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    '',
    ''
);
----
100

# Test 5.2: Zero salt_count should return 0 rows
query I
SELECT COUNT(*) FROM create2_mine(
    '0x4e59b44847b379578588920ca78fbf26c0b4956c',
    '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '100'
);
----
0

# Test 5.3: Hex salt values should work
query II
SELECT salt_hi, salt_lo
FROM create2_mine(
    '0x4e59b44847b379578588920ca78fbf26c0b4956c',
    '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
    '0x3e8',  -- 1000 in hex
    '2',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '100'
)
LIMIT 2;
----
0	1000
0	1001

# Test 6.1: Large salt values - verify rollover to salt_hi
query II
SELECT salt_hi, salt_lo
FROM create2_mine(
    '0x4e59b44847b379578588920ca78fbf26c0b4956c',
    '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
    '18446744073709551615',  -- Max uint64
    '2',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '100'
);
----
0	18446744073709551615
1	0

# Test 6.2: Test leading/trailing zero bits columns exist and are reasonable
query I
SELECT COUNT(*) FROM create2_mine(
    '0x4e59b44847b379578588920ca78fbf26c0b4956c',
    '0x2222222222222222222222222222222222222222222222222222222222222222',
    '0',
    '100',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '100'
) WHERE lz_bits >= 0 AND lz_bits <= 160 AND tz_bits >= 0 AND tz_bits <= 160;
----
100

# Test 7.1: Verify human-readable salt column returns valid hex string
query I
SELECT salt LIKE '0x%' AND LENGTH(salt) = 66 FROM create2_mine(
    '0x4e59b44847b379578588920ca78fbf26c0b4956c',
    '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
    '0',
    '1',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '100'
);
----
true

# Test 7.1b: format_salt function still works for backward compatibility
query I
SELECT format_salt(salt_hi, salt_lo) LIKE '0x%' FROM create2_mine(
    '0x4e59b44847b379578588920ca78fbf26c0b4956c',
    '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
    '0',
    '1',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '100'
);
----
true

# Test 7.2: Verify human-readable address column returns valid ethereum address
query I
SELECT address LIKE '0x%' AND LENGTH(address) = 42
FROM create2_mine(
    '0x4e59b44847b379578588920ca78fbf26c0b4956c',
    '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
    '0',
    '1',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '100'
);
----
true

# Test 7.2b: format_address function still works for backward compatibility
query I
SELECT format_address(addr_hi8, addr_mid8, addr_lo4) LIKE '0x%' 
   AND LENGTH(format_address(addr_hi8, addr_mid8, addr_lo4)) = 42
FROM create2_mine(
    '0x4e59b44847b379578588920ca78fbf26c0b4956c',
    '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
    '0',
    '1',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '100'
);
----
true

# Test 7.3: Verify addresses are deterministic (same input = same output)
query I
SELECT COUNT(DISTINCT address) FROM (
    SELECT * FROM create2_mine(
        '0x4e59b44847b379578588920ca78fbf26c0b4956c',
        '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
        '100',
        '1',
        '0',
        '0',
        '0',
        '0',
        '0',
        '0',
        '100'
    )
    UNION ALL
    SELECT * FROM create2_mine(
        '0x4e59b44847b379578588920ca78fbf26c0b4956c',
        '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
        '100',
        '1',
        '0',
        '0',
        '0',
        '0',
        '0',
        '0',
        '100'
    )
);
----
1

# Test 7.3b: Verify salt and address match their component versions
query I
SELECT salt = format_salt(salt_hi, salt_lo) AND address = format_address(addr_hi8, addr_mid8, addr_lo4)
FROM create2_mine(
    '0x4e59b44847b379578588920ca78fbf26c0b4956c',
    '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
    '100',
    '1',
    '0',
    '0',
    '0',
    '0',
    '0',
    '0',
    '100'
);
----
true

# Test 8.1: Mix of string and numeric inputs should work
query I
SELECT COUNT(*) FROM create2_mine(
    '0x4e59b44847b379578588920ca78fbf26c0b4956c',
    '0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef',
    '1000',         -- numeric as string
    '50',           -- string
    '0',            -- null -> '0' (uses default)
    '0x00',         -- hex string (fixed: even number of digits)
    '0',            -- numeric as string
    '0',            -- null -> '0' (uses default) 
    '0x00',         -- hex string
    '0',            -- numeric as string
    '50'            -- numeric as string
);
----
50